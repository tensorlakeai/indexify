
# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_STRUCT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/google.protobuf.Struct")] impl :: prost_wkt :: MessageSerde for Struct { fn package_name (& self) -> & 'static str { "google.protobuf" } fn message_name (& self) -> & 'static str { "Struct" } fn type_url (& self) -> & 'static str { "type.googleapis.com/google.protobuf.Struct" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: with_capacity (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/google.protobuf.Struct" , decoder : | buf : & [u8] | { let msg : Struct = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } impl :: prost :: Name for Struct { const PACKAGE : & 'static str = "google.protobuf" ; const NAME : & 'static str = "Struct" ; fn type_url () -> String { "type.googleapis.com/google.protobuf.Struct" . to_string () } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_VALUE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/google.protobuf.Value")] impl :: prost_wkt :: MessageSerde for Value { fn package_name (& self) -> & 'static str { "google.protobuf" } fn message_name (& self) -> & 'static str { "Value" } fn type_url (& self) -> & 'static str { "type.googleapis.com/google.protobuf.Value" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: with_capacity (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/google.protobuf.Value" , decoder : | buf : & [u8] | { let msg : Value = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } impl :: prost :: Name for Value { const PACKAGE : & 'static str = "google.protobuf" ; const NAME : & 'static str = "Value" ; fn type_url () -> String { "type.googleapis.com/google.protobuf.Value" . to_string () } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_LIST_VALUE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/google.protobuf.ListValue")] impl :: prost_wkt :: MessageSerde for ListValue { fn package_name (& self) -> & 'static str { "google.protobuf" } fn message_name (& self) -> & 'static str { "ListValue" } fn type_url (& self) -> & 'static str { "type.googleapis.com/google.protobuf.ListValue" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: with_capacity (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/google.protobuf.ListValue" , decoder : | buf : & [u8] | { let msg : ListValue = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } impl :: prost :: Name for ListValue { const PACKAGE : & 'static str = "google.protobuf" ; const NAME : & 'static str = "ListValue" ; fn type_url () -> String { "type.googleapis.com/google.protobuf.ListValue" . to_string () } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_STRUCT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/google.protobuf.Struct")] impl :: prost_wkt :: MessageSerde for Struct { fn package_name (& self) -> & 'static str { "google.protobuf" } fn message_name (& self) -> & 'static str { "Struct" } fn type_url (& self) -> & 'static str { "type.googleapis.com/google.protobuf.Struct" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: with_capacity (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/google.protobuf.Struct" , decoder : | buf : & [u8] | { let msg : Struct = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } impl :: prost :: Name for Struct { const PACKAGE : & 'static str = "google.protobuf" ; const NAME : & 'static str = "Struct" ; fn type_url () -> String { "type.googleapis.com/google.protobuf.Struct" . to_string () } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_VALUE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/google.protobuf.Value")] impl :: prost_wkt :: MessageSerde for Value { fn package_name (& self) -> & 'static str { "google.protobuf" } fn message_name (& self) -> & 'static str { "Value" } fn type_url (& self) -> & 'static str { "type.googleapis.com/google.protobuf.Value" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: with_capacity (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/google.protobuf.Value" , decoder : | buf : & [u8] | { let msg : Value = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } impl :: prost :: Name for Value { const PACKAGE : & 'static str = "google.protobuf" ; const NAME : & 'static str = "Value" ; fn type_url () -> String { "type.googleapis.com/google.protobuf.Value" . to_string () } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_LIST_VALUE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/google.protobuf.ListValue")] impl :: prost_wkt :: MessageSerde for ListValue { fn package_name (& self) -> & 'static str { "google.protobuf" } fn message_name (& self) -> & 'static str { "ListValue" } fn type_url (& self) -> & 'static str { "type.googleapis.com/google.protobuf.ListValue" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: with_capacity (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/google.protobuf.ListValue" , decoder : | buf : & [u8] | { let msg : ListValue = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } impl :: prost :: Name for ListValue { const PACKAGE : & 'static str = "google.protobuf" ; const NAME : & 'static str = "ListValue" ; fn type_url () -> String { "type.googleapis.com/google.protobuf.ListValue" . to_string () } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_STRUCT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/google.protobuf.Struct")] impl :: prost_wkt :: MessageSerde for Struct { fn package_name (& self) -> & 'static str { "google.protobuf" } fn message_name (& self) -> & 'static str { "Struct" } fn type_url (& self) -> & 'static str { "type.googleapis.com/google.protobuf.Struct" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: with_capacity (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/google.protobuf.Struct" , decoder : | buf : & [u8] | { let msg : Struct = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } impl :: prost :: Name for Struct { const PACKAGE : & 'static str = "google.protobuf" ; const NAME : & 'static str = "Struct" ; fn type_url () -> String { "type.googleapis.com/google.protobuf.Struct" . to_string () } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_VALUE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/google.protobuf.Value")] impl :: prost_wkt :: MessageSerde for Value { fn package_name (& self) -> & 'static str { "google.protobuf" } fn message_name (& self) -> & 'static str { "Value" } fn type_url (& self) -> & 'static str { "type.googleapis.com/google.protobuf.Value" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: with_capacity (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/google.protobuf.Value" , decoder : | buf : & [u8] | { let msg : Value = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } impl :: prost :: Name for Value { const PACKAGE : & 'static str = "google.protobuf" ; const NAME : & 'static str = "Value" ; fn type_url () -> String { "type.googleapis.com/google.protobuf.Value" . to_string () } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_LIST_VALUE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/google.protobuf.ListValue")] impl :: prost_wkt :: MessageSerde for ListValue { fn package_name (& self) -> & 'static str { "google.protobuf" } fn message_name (& self) -> & 'static str { "ListValue" } fn type_url (& self) -> & 'static str { "type.googleapis.com/google.protobuf.ListValue" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: with_capacity (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/google.protobuf.ListValue" , decoder : | buf : & [u8] | { let msg : ListValue = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } impl :: prost :: Name for ListValue { const PACKAGE : & 'static str = "google.protobuf" ; const NAME : & 'static str = "ListValue" ; fn type_url () -> String { "type.googleapis.com/google.protobuf.ListValue" . to_string () } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_STRUCT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/google.protobuf.Struct")] impl :: prost_wkt :: MessageSerde for Struct { fn package_name (& self) -> & 'static str { "google.protobuf" } fn message_name (& self) -> & 'static str { "Struct" } fn type_url (& self) -> & 'static str { "type.googleapis.com/google.protobuf.Struct" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: with_capacity (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/google.protobuf.Struct" , decoder : | buf : & [u8] | { let msg : Struct = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } impl :: prost :: Name for Struct { const PACKAGE : & 'static str = "google.protobuf" ; const NAME : & 'static str = "Struct" ; fn type_url () -> String { "type.googleapis.com/google.protobuf.Struct" . to_string () } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_VALUE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/google.protobuf.Value")] impl :: prost_wkt :: MessageSerde for Value { fn package_name (& self) -> & 'static str { "google.protobuf" } fn message_name (& self) -> & 'static str { "Value" } fn type_url (& self) -> & 'static str { "type.googleapis.com/google.protobuf.Value" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: with_capacity (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/google.protobuf.Value" , decoder : | buf : & [u8] | { let msg : Value = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } impl :: prost :: Name for Value { const PACKAGE : & 'static str = "google.protobuf" ; const NAME : & 'static str = "Value" ; fn type_url () -> String { "type.googleapis.com/google.protobuf.Value" . to_string () } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_LIST_VALUE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/google.protobuf.ListValue")] impl :: prost_wkt :: MessageSerde for ListValue { fn package_name (& self) -> & 'static str { "google.protobuf" } fn message_name (& self) -> & 'static str { "ListValue" } fn type_url (& self) -> & 'static str { "type.googleapis.com/google.protobuf.ListValue" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: with_capacity (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/google.protobuf.ListValue" , decoder : | buf : & [u8] | { let msg : ListValue = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } impl :: prost :: Name for ListValue { const PACKAGE : & 'static str = "google.protobuf" ; const NAME : & 'static str = "ListValue" ; fn type_url () -> String { "type.googleapis.com/google.protobuf.ListValue" . to_string () } } } ;
