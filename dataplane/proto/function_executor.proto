syntax = "proto3";

import "google/protobuf/timestamp.proto";

package function_executor_service;

// The messages should not use any Python SDK objects. Only Function Executor implemented
// in Python is allowed to import Python SDK to run customer functions. This ensures that
// all the other components can be written in any language.

// The standard Empty message.
message Empty {}

enum SerializedObjectEncoding {
    SERIALIZED_OBJECT_ENCODING_UNKNOWN = 0;
    SERIALIZED_OBJECT_ENCODING_UTF8_JSON = 1;
    SERIALIZED_OBJECT_ENCODING_UTF8_TEXT = 2;
    SERIALIZED_OBJECT_ENCODING_BINARY_PICKLE = 3;
    SERIALIZED_OBJECT_ENCODING_BINARY_ZIP = 4;
    SERIALIZED_OBJECT_ENCODING_RAW = 5;
}

message SerializedObjectManifest {
    optional SerializedObjectEncoding encoding = 1;
    optional uint64 encoding_version = 2;
    // Includes data and metadata.
    optional uint64 size = 3;
    // Metadata is stored before the actual data.
    optional uint64 metadata_size = 4;
    // Includes data and metadata.
    optional string sha256_hash = 5;
    // MIME type. Only set when raw encoding is used.
    optional string content_type = 6;
    // ID of the function call that returned this SO as it's return value.
    // SOs which are not a function call return value, don't have this field set.
    optional string source_function_call_id = 7;
}

// Full serialized object with all its data.
message SerializedObject {
    optional SerializedObjectManifest manifest = 1;
    optional bytes data = 2;
}

// A chunk of a BLOB in a BLOB store.
message BLOBChunk {
    // URI of the chunk.
    // S3 URI if the data is stored in S3.
    // Starts with "file://"" prefix if the data is stored on a local file system.
    optional string uri = 1;
    // Actual size of chunk data if the BLOB has data.
    // Max chunk size if the BLOB has no data yet (can be used for data upload).
    optional uint64 size = 2;
    // None if the BLOB has data.
    // ETag of the chunk data (generated by BLOB store) if the BLOB chunk was used to upload data.
    optional string etag = 3;
}

// A BLOB in a BLOB store.
message BLOB {
    // ID of the BLOB, unique per allocation.
    optional string id = 1;
    // Ordered chunks of the BLOB if the BLOB has data.
    // Ordered chunks of the BLOB that can be used to upload data if the BLOB has no data yet.
    repeated BLOBChunk chunks = 2;
}

// Serialized object stored inside a BLOB.
// The BLOB is determined from the protocol context.
message SerializedObjectInsideBLOB {
    optional SerializedObjectManifest manifest = 1;
    // Offset inside the BLOB where the serialized object data starts.
    optional uint64 offset = 2;
}

message FunctionRef {
  optional string namespace = 1;
  optional string application_name = 2;
  optional string function_name = 3;
  optional string application_version = 4;
}

// InitializeRequest contains information about the function
// that Function Executor is going to run the allocation for.
message InitializeRequest {
    optional FunctionRef function = 1;
    optional SerializedObject application_code = 2;
}

enum InitializationOutcomeCode {
    INITIALIZATION_OUTCOME_CODE_UNKNOWN = 0;
    INITIALIZATION_OUTCOME_CODE_SUCCESS = 1;
    INITIALIZATION_OUTCOME_CODE_FAILURE = 2;
}

enum InitializationFailureReason {
    INITIALIZATION_FAILURE_REASON_UNKNOWN = 0;
    INITIALIZATION_FAILURE_REASON_INTERNAL_ERROR = 1;
    INITIALIZATION_FAILURE_REASON_FUNCTION_ERROR = 2;
}

message InitializeResponse {
    optional InitializationOutcomeCode outcome_code = 1;
    optional InitializationFailureReason failure_reason = 2;
}

message SetRequestStateRequest {
    optional string key = 1;
    optional SerializedObject value = 2;
}

message SetRequestStateResponse {}

message GetRequestStateRequest {
    optional string key = 1;
}

message GetRequestStateResponse {
    optional string key = 1;
    optional SerializedObject value = 2;
}

// RequestStateRequest is sent by RPC Server to the client
// to perform actions on a allocation's request state.
message RequestStateRequest {
    // The ID of the state request sent by the client.
    // Must be unique per Function Executor.
    optional string state_request_id = 1;
    // The ID of the allocation initiated the request.
    optional string allocation_id = 2;
    oneof request {
        SetRequestStateRequest set = 3;
        GetRequestStateRequest get = 4;
    }
}

// RequestStateResponse is sent by RPC client to the Server.
// A response contains the result of the action performed on the
// allocation's request state.
message RequestStateResponse {
    // The id of the state request this response is for.
    optional string state_request_id = 1;
    optional bool success = 2;
    oneof response {
        SetRequestStateResponse set = 3;
        GetRequestStateResponse get = 4;
    }
}

message ListAllocationsRequest {}

message ListAllocationsResponse {
  repeated Allocation allocations = 1;
}

message Metrics {
    map<string, float> timers = 1;
    map<string, uint64> counters = 2;
}

enum AllocationOutcomeCode {
    ALLOCATION_OUTCOME_CODE_UNKNOWN = 0;
    ALLOCATION_OUTCOME_CODE_SUCCESS = 1;
    ALLOCATION_OUTCOME_CODE_FAILURE = 2;
}

enum AllocationFailureReason {
    ALLOCATION_FAILURE_REASON_UNKNOWN = 0;
    ALLOCATION_FAILURE_REASON_INTERNAL_ERROR = 1;
    ALLOCATION_FAILURE_REASON_FUNCTION_ERROR = 2;
    ALLOCATION_FAILURE_REASON_REQUEST_ERROR = 3;
}

message AllocationProgress {
    float current = 1;
    float total = 2;
}

message AllocationOutputBLOBRequest {
    // ID of the BLOB, unique per allocation.
    optional string id = 1;
    optional uint64 size = 2;
}

message AllocationFunctionCall {
    // Call ID is the same as root_function_call_id in ExecutionPlanUpdates.
    optional ExecutionPlanUpdates updates = 1;
    // SerializedObjectInsideBLOB arguments from the execution
    // plan are stored inside this BLOB.
    // Optional, not set if no function arguments in updates.
    optional BLOB args_blob = 2;
}

message AllocationFunctionCallWatcher {
    optional string watcher_id = 1;
    // Only root_function_call_id of ExecutionPlanUpdates can be watched.
    optional string function_call_id = 2;
}

message AllocationState {
    // Optional current allocation progress.
    optional AllocationProgress progress = 1;
    // Requests for writable BLOBs so allocation can upload data there.
    repeated AllocationOutputBLOBRequest output_blob_requests = 2;
    // Function calls started by the allocation.
    // New function calls are detected by client when it sees a new
    // ExecutionPlanUpdates.root_function_call_id.
    //
    // If a not finished function call gets removed from this list then
    // it doesn't get cancelled by the client. ExecutionPlanUpdates are immutable.
    repeated AllocationFunctionCall function_calls = 3;
    // Watchers for function calls started by the allocation.
    repeated AllocationFunctionCallWatcher function_call_watchers = 4;
    // Optional allocation result. Set when allocation finishes.
    AllocationResult result = 5;
    // Required state hash.
    optional string sha256_hash = 6;
}

// FunctionInputs contains the input data for allocation execution
message FunctionInputs {
    repeated SerializedObjectInsideBLOB args = 1;
    // Each arg has a matching BLOB.
    repeated BLOB arg_blobs = 2;
    // BLOB where to upload request error message if allocation fails with request error.
    optional BLOB request_error_blob = 3;
    // Always set. An empty bytes array if no metadata, e.g. for API function call.
    optional bytes function_call_metadata = 4;
}

message FunctionArg {
  oneof source {
    // Data dependency reference to another function call.
    string function_call_id = 1;
    // Stored inside uploaded_function_outputs_blob.
    SerializedObjectInsideBLOB value = 2;
  }
}

message FunctionCall {
    optional string id = 1;
    optional FunctionRef target = 2;
    repeated FunctionArg args = 3;
    optional bytes call_metadata = 4;
}

message ReduceOp {
    optional string id = 1;
    // Contains at least two items.
    repeated FunctionArg collection = 2;
    optional FunctionRef reducer = 3;
    optional bytes call_metadata = 4;
}


message ExecutionPlanUpdate {
  oneof op {
    FunctionCall function_call = 10;
    ReduceOp     reduce        = 12;
  }
}

message ExecutionPlanUpdates {
  repeated ExecutionPlanUpdate updates = 1;
  optional string root_function_call_id = 2;
  // Optional timestamp for when to start the plan execution.
  optional google.protobuf.Timestamp start_at = 3;
}

// AllocationResult contains the execution outcome and outputs of an allocation.
message AllocationResult {
    optional AllocationOutcomeCode outcome_code = 1;
    optional AllocationFailureReason failure_reason = 2;
    oneof outputs {
        SerializedObjectInsideBLOB value = 3;
        ExecutionPlanUpdates updates = 4;
    }
    // The function_outputs_blob with uploaded function outputs.
    optional BLOB uploaded_function_outputs_blob = 5;
    // User payload for request error if allocation failed with request error.
    // Stored inside uploaded_request_error_blob.
    optional SerializedObjectInsideBLOB request_error_output = 6;
    // The request_error_blob with uploaded request error output, if any.
    optional BLOB uploaded_request_error_blob = 7;
    optional Metrics metrics = 8;
}

// Allocation represents an allocation with its metadata and execution result
message Allocation {
    optional string request_id = 1;
    optional string function_call_id = 2;
    optional string allocation_id = 3;
    // Original allocation inputs.
    optional FunctionInputs inputs = 4;
    // Set when allocation finishes.
    optional AllocationResult result = 5;
}

message CreateAllocationRequest {
    optional Allocation allocation = 1;
}

message WatchAllocationStateRequest {
    optional string allocation_id = 1;
}

message DeleteAllocationRequest {
    optional string allocation_id = 1;
}

message AllocationFunctionCallResult {
    // From ExecutionPlanUpdates.root_function_call_id.
    optional string function_call_id = 1;
    optional AllocationOutcomeCode outcome_code = 2;
    optional SerializedObjectInsideBLOB value_output = 3;
    optional BLOB value_blob = 4;
    optional SerializedObjectInsideBLOB request_error_output = 5;
    optional BLOB request_error_blob = 6;
}

message AllocationUpdate {
    // Target allocation ID.
    optional string allocation_id = 1;
    oneof update {
        // Function call result if the function call is watched by allocation.
        AllocationFunctionCallResult function_call_result = 2;
        // Output BLOB if requested by allocation.
        BLOB output_blob = 3;
    }
}

message HealthCheckRequest {}

message HealthCheckResponse {
    optional bool healthy = 1;
    optional string status_message = 2;
}

message InfoRequest {}

message InfoResponse {
    // Internal version of this Function Executor.
    // Semantic versioning schema is used with format 0.0.0.
    // Used to support migrations.
    optional string version = 1;
    // The version of the SDK used in this Function Executor to run customer code.
    optional string sdk_version = 2;
    // The language of the SDK. Currently supported values:
    // - "python"
    optional string sdk_language = 3;
    // The version of the SDK language. The language's versioning format is used.
    optional string sdk_language_version = 4;
}

service FunctionExecutor {
    // Initializes the Function Executor to run allocations
    // for a particular function. This method is called only
    // once per Function Executor as it can only run a single function.
    // It should be called before calling create_allocation.
    rpc initialize(InitializeRequest) returns (InitializeResponse);
    // Initializes a server that sends requests to the client to perform actions on an allocation's
    // request state. This method is called only once per Function Executor
    // It should be called before calling create_allocation.
    rpc initialize_request_state_server(stream RequestStateResponse) returns (stream RequestStateRequest);
    // Lists the currently-running allocations.
    rpc list_allocations(ListAllocationsRequest) returns (ListAllocationsResponse);
    // Creates and starts the allocation specified in the request.
    rpc create_allocation(CreateAllocationRequest) returns (Empty);
    // Streams updates of the allocation state until allocation finishes.
    // If allocation is finished, streams the final state and closes the stream.
    rpc watch_allocation_state(WatchAllocationStateRequest) returns (stream AllocationState);
    // Deletes the allocation. The allocation must be finished before calling this method.
    rpc delete_allocation(DeleteAllocationRequest) returns (Empty);
    // Send an update to an allocation.
    rpc send_allocation_update(AllocationUpdate) returns (Empty);
    // Health check method to check if the FE is able to run allocations.
    // The FE should be initialized before calling this method.
    rpc check_health(HealthCheckRequest) returns (HealthCheckResponse);
    // Information about this Function Executor.
    rpc get_info(InfoRequest) returns (InfoResponse);
}
