syntax = "proto3";

// Rename with caution. The package name is part of gRPC service name.
// Existing clients won't find the service if the package name changes.
package executor_api_pb;

import "google/protobuf/timestamp.proto";

// ===== DataPayload =====
enum DataPayloadEncoding {
  DATA_PAYLOAD_ENCODING_UNKNOWN = 0;
  DATA_PAYLOAD_ENCODING_UTF8_JSON = 1;
  DATA_PAYLOAD_ENCODING_UTF8_TEXT = 2;
  DATA_PAYLOAD_ENCODING_BINARY_PICKLE = 3;
  DATA_PAYLOAD_ENCODING_BINARY_ZIP = 4;
  DATA_PAYLOAD_ENCODING_RAW = 5;
}

message DataPayload {
  // URI of the BLOB where the data is stored.
  // S3 URI if the data is stored in S3.
  // Starts with "file://"" prefix if the data is stored on a local file system.
  optional string uri = 1;
  optional DataPayloadEncoding encoding = 2;
  // Not set and ignored by Server right now.
  optional uint64 encoding_version = 3;
  // MIME type. Only set when raw encoding is used.
  optional string content_type = 4;

  // DataPayload metadata is stored at the head of the binary
  // blob. This metadata is used optionally to store additional
  // metadata for the type of the object that is stored
  // so that we can deserialize the object correctly.
  optional uint64 metadata_size = 5;

  optional uint64 offset = 6;
  // Includes data and metadata.
  optional uint64 size = 7;
  optional string sha256_hash = 8;

  // ID of the function call that returned this data payload as it's return value.
  // Payloads which are not a function call return value, don't have this field set.
  optional string source_function_call_id = 9;

  // Opaque ID. Generated by Server if not set by Executor.
  optional string id = 10;
}

enum GPUModel {
  GPU_MODEL_UNKNOWN = 0;
  GPU_MODEL_NVIDIA_A100_40GB = 1;
  GPU_MODEL_NVIDIA_A100_80GB = 2;
  GPU_MODEL_NVIDIA_H100_80GB = 3;
  GPU_MODEL_NVIDIA_TESLA_T4 = 4;
  GPU_MODEL_NVIDIA_A6000 = 5;
  GPU_MODEL_NVIDIA_A10 = 6;
}

// Free GPUs available at the Executor.
message GPUResources {
  optional uint32 count = 1;
  optional GPUModel model = 2;
}

// Resources that we're currently tracking and limiting on Executor.
message HostResources {
  optional uint32 cpu_count = 1;
  optional uint64 memory_bytes = 2;
  optional uint64 disk_bytes = 3;
  // Not set if no GPUs are available.
  optional GPUResources gpu = 4;
}

// Specification of a single function that is allowed to be run on the Executor.
message AllowedFunction {
  optional string namespace = 1;
  optional string application_name = 2;
  optional string function_name = 3;
  // If none then any version of the application is allowed to run on the Executor.
  optional string application_version = 4;
}

enum ContainerStatus {
  CONTAINER_STATUS_UNKNOWN = 0;
  // Container is being created.
  CONTAINER_STATUS_PENDING = 1;
  // Container is running and ready to accept allocations.
  CONTAINER_STATUS_RUNNING = 2;
  // Container is terminated, all resources are freed.
  CONTAINER_STATUS_TERMINATED = 3;
}

enum ContainerType {
  CONTAINER_TYPE_UNKNOWN = 0;
  CONTAINER_TYPE_FUNCTION = 1;
  CONTAINER_TYPE_SANDBOX = 2;
}

// Resources allocated to a container.
message ContainerResources {
  // 1000 CPU ms per sec is one full CPU core.
  // 2000 CPU ms per sec is two full CPU cores.
  optional uint32 cpu_ms_per_sec = 1;
  optional uint64 memory_bytes = 2;
  optional uint64 disk_bytes = 3;
  optional GPUResources gpu = 4;
}

message FunctionRef {
  optional string namespace = 1;
  optional string application_name = 2;
  optional string function_name = 3;
  optional string application_version = 4;
}

// Network access control policy for sandboxes.
// Rules are applied using host-level iptables on the DOCKER-USER chain.
message NetworkPolicy {
  // If false, all outbound internet access is blocked by default (DROP).
  // If true (default), outbound is allowed unless explicitly denied.
  optional bool allow_internet_access = 1;
  // List of allowed destination IPs/CIDRs (e.g., "8.8.8.8", "10.0.0.0/8").
  // Allow rules take precedence over deny rules.
  repeated string allow_out = 2;
  // List of denied destination IPs/CIDRs (e.g., "192.168.1.100").
  repeated string deny_out = 3;
}

message SandboxMetadata {
  // timeout after which the sandbox is killed
  // by the dataplane
  optional uint64 timeout_secs = 11;
  // user specified entrypoint. if provided
  // container daemon starts this as a child process
  // during sandbox initialization and shows this as one
  // of the pid
  repeated string entrypoint = 12;
  // container image of the sandbox
  optional string image = 10;
  // Network access control policy for sandbox containers.
  optional NetworkPolicy network_policy = 13;
  // The sandbox this container is serving (if any).
  // Unset for warm pool containers, set when claimed by a sandbox.
  optional string sandbox_id = 14;
  // URI of the snapshot to restore from (e.g. "s3://bucket/snap.tar.zst").
  // When set, the dataplane restores this snapshot instead of using the base image.
  optional string snapshot_uri = 16;
}

// Describes a container managed by the dataplane.
// Covers both function containers and sandbox containers.
message ContainerDescription {
  optional string id = 1;
  optional FunctionRef function = 2;
  repeated string secret_names = 3;
  // Timeout for customer code duration during container creation.
  optional uint32 initialization_timeout_ms = 4;
  optional DataPayload application = 5;
  optional ContainerResources resources = 6;
  optional uint32 max_concurrency = 8;
  // Timeout for running allocations on this container.
  optional uint32 allocation_timeout_ms = 9;

  // Sandbox related metadata, only set when container_type
  // is set to sandbox
  optional SandboxMetadata sandbox_metadata = 10;
  // Type of this container (function or sandbox).
  optional ContainerType container_type = 13;
  // Pool this container belongs to. Every container belongs to a pool.
  optional string pool_id = 14;
}

message ContainerState {
  optional ContainerDescription description = 1;
  optional ContainerStatus status = 2;
  optional ContainerTerminationReason termination_reason = 3;
  // Field 4 (allocation_ids_caused_termination) removed — blame tracking is
  // now handled by the dataplane via per-allocation AllocationFailed messages.
}

enum ExecutorStatus {
  EXECUTOR_STATUS_UNKNOWN = 0;
  // Executor is starting up, not ready to accept allocations and containers.
  EXECUTOR_STATUS_STARTING_UP = 1;
  // Executor is ready to accept allocations and containers.
  EXECUTOR_STATUS_RUNNING = 2;
  // No new allocations or containers should be placed on the Executor.
  EXECUTOR_STATUS_DRAINED = 3;
  // Executor is stopped, all resources are freed, all containers are terminated.
  EXECUTOR_STATUS_STOPPED = 4;
  // Executor is cordoned - no new allocations or FEs should be placed on it.
  EXECUTOR_STATUS_SCHEDULING_DISABLED = 5;
}

message ExecutorState {
  optional string executor_id = 1;
  optional string hostname = 3;
  optional string version = 5;
  optional ExecutorStatus status = 6;
  // Total resources at the Executor.
  optional HostResources total_resources = 13;
  // Total resources usable by containers.
  optional HostResources total_container_resources = 7;
  // Empty allowed_functions list means that any function can run on the Executor.
  repeated AllowedFunction allowed_functions = 8;
  repeated ContainerState container_states = 9;
  map<string, string> labels = 10;
  optional string state_hash = 11;
  // Server supplied clock value of the latest desired executor state that was
  // reconciled by Executor. Not included into state_hash.
  // Initial value on Executor startup is 0.
  optional uint64 server_clock = 12;

  // Catalog entry name that this executor is associated with.
  optional string catalog_entry_name = 14;

  reserved 15; // was function_call_watches — watchers eliminated by allocation_stream

  // Address of the HTTP proxy (host:port) for routing sandbox traffic.
  optional string proxy_address = 16;
}

// Updates that Executor wants to report to Server. If report_executor_state RPC is successful
// then the updates from it won't be included in the next RPC.
message ExecutorUpdate {
  optional string executor_id = 1;
  repeated AllocationResult allocation_results = 2;
}

// FunctionCallWatch removed — watchers eliminated by allocation_stream.

enum ReplayMode {
  REPLAY_MODE_NONE = 0; // Initial run, no replay
  REPLAY_MODE_STRICT = 1; // Deterministic replay, fail on mismatch
  REPLAY_MODE_ADAPTIVE = 2; // Replay what matches, re-execute on divergence
}

message Allocation {
  // Version is not set in function ref.
  optional FunctionRef function = 1;
  optional string allocation_id = 2;
  optional string function_call_id = 3;
  optional string request_id = 4;
  repeated DataPayload args = 5;
  // URI prefix for DataPayloads/BLOBs generated by the Allocation request.
  // S3 URI if the data is stored in S3.
  // Starts with "file://"" prefix followed by an absolute directory path if the data is stored on a local file system.
  optional string request_data_payload_uri_prefix = 6;
  // BLOB URI prefix for the request error payloads.
  optional string request_error_payload_uri_prefix = 7;
  optional string container_id = 8;

  // Always set. An empty bytes array if no metadata, e.g. for API function call.
  optional bytes function_call_metadata = 9;

  // === Durable execution (v2) ===

  // Controls how the executor handles this allocation.
  // Unset or REPLAY_MODE_NONE for initial runs (no replay).
  // REPLAY_MODE_STRICT: deterministic replay, fail on mismatch.
  // REPLAY_MODE_ADAPTIVE: replay what matches, re-execute on divergence.
  optional ReplayMode replay_mode = 10;

  // Clock value of the last event in the server-side log for this allocation.
  // Executor uses this to know how far to replay before resuming live execution.
  optional uint64 last_event_clock = 11;
}

message FunctionCallResult {
  optional string namespace = 1;
  optional string request_id = 2;
  optional string function_call_id = 4;
  optional AllocationOutcomeCode outcome_code = 5;
  optional AllocationFailureReason failure_reason = 6;
  optional DataPayload return_value = 7;
  optional DataPayload request_error = 9;
}

enum AllocationOutcomeCode {
  ALLOCATION_OUTCOME_CODE_UNKNOWN = 0;
  ALLOCATION_OUTCOME_CODE_SUCCESS = 1;
  ALLOCATION_OUTCOME_CODE_FAILURE = 2;
}

enum AllocationFailureReason {
  ALLOCATION_FAILURE_REASON_UNKNOWN = 0;
  // Internal error on Executor aka platform error.
  ALLOCATION_FAILURE_REASON_INTERNAL_ERROR = 1;
  // Clear function code failure typically by raising an exception from the function code.
  // Also a grey failure where we can't determine the exact cause. We attribute these to
  // functions to prevent service abuse but not billed intenionally failing functions.
  ALLOCATION_FAILURE_REASON_FUNCTION_ERROR = 2;
  // Function code run time exceeded its configured timeout.
  ALLOCATION_FAILURE_REASON_FUNCTION_TIMEOUT = 3;
  // Function code raised RequestException to mark the request as permanently failed.
  ALLOCATION_FAILURE_REASON_REQUEST_ERROR = 4;
  // Server removed the allocation from Executor desired state.
  // The allocation was either running or didn't start before the removal.
  // If it started running then its execution duration is set.
  ALLOCATION_FAILURE_REASON_ALLOCATION_CANCELLED = 5;
  // Container terminated, can't run the allocation on it anymore.
  // The allocation didn't run on the container.
  ALLOCATION_FAILURE_REASON_CONTAINER_TERMINATED = 6;
  // Out of memory error.
  ALLOCATION_FAILURE_REASON_OOM = 7;
  // The below failure reasons are only set by Server when reporting function call results
  // back to Executor.
  //
  // Function run cannot be scheduled given its constraints.
  // This shouldn't be allocation failure, but since we are reusing
  // allocation failure reasons as function run failure reasons, we need to add it here.
  ALLOCATION_FAILURE_REASON_CONSTRAINT_UNSATISFIABLE = 8;
  // Another failure reason which doesn't make sense to put here
  // but this is one of the function run reasons - again shouldn't happen in practice,
  ALLOCATION_FAILURE_REASON_EXECUTOR_REMOVED = 9;

  // Internal error aka platform error on container startup.
  ALLOCATION_FAILURE_REASON_STARTUP_FAILED_INTERNAL_ERROR = 10;
  // A clear function constructor code error on container startup.
  // Typically an exception raised from the constructor.
  ALLOCATION_FAILURE_REASON_STARTUP_FAILED_FUNCTION_ERROR = 11;
  // Timeout on container startup while running the function constructor.
  ALLOCATION_FAILURE_REASON_STARTUP_FAILED_FUNCTION_TIMEOUT = 12;

  // Image-related failure on container startup (missing image, bad image name, pull failure).
  ALLOCATION_FAILURE_REASON_STARTUP_FAILED_BAD_IMAGE = 13;
}

message ExecutionPlanUpdate {
  oneof op {
    FunctionCall function_call = 10;
    ReduceOp reduce = 12;
  }
}

message FunctionCall {
  // The ID of the function call.
  // When all the dependencies of the function call are resolved, the
  // resulting DataPayload will have the same ID.
  // This allows resolving datapayloads of resolved functions calls when it's upstream is called again.
  // The ID is unique within the scope of the request.
  optional string id = 1;
  optional FunctionRef target = 2;
  repeated FunctionArg args = 3;

  // This required metadata allows SDK to restore original function call from the arguments.
  optional bytes call_metadata = 5;
}

message FunctionArg {
  oneof source {
    string function_call_id = 1;
    DataPayload inline_data = 2;
  }
}

message ReduceOp {
  // The DataPayload of the last function call in the reducer will have the function call id set
  // as the id of the ReduceOp.
  optional string id = 1;
  // Contains at least two items.
  repeated FunctionArg collection = 2;
  optional FunctionRef reducer = 3;
  // This required metadata allows SDK to restore original function call from the arguments.
  optional bytes call_metadata = 4;
}

message ExecutionPlanUpdates {
  repeated ExecutionPlanUpdate updates = 1;
  optional string root_function_call_id = 2;
  // Optional timestamp for when to start the plan execution.
  optional google.protobuf.Timestamp start_at = 3;
}

message AllocationResult {
  optional FunctionRef function = 1;
  optional string allocation_id = 2;
  optional string function_call_id = 3;
  optional string request_id = 4;
  optional AllocationOutcomeCode outcome_code = 5;
  optional AllocationFailureReason failure_reason = 6;

  oneof return_value {
    DataPayload value = 7;
    ExecutionPlanUpdates updates = 8;
  }
  // User payload for request error if allocation failed with request error.
  optional DataPayload request_error = 9;
  optional uint64 execution_duration_ms = 10;
}

message FunctionCallRequest {
  optional string namespace = 1;
  optional string application = 2;
  // The ID of request in which the function call
  // needs to run.
  optional string request_id = 3;
  // Function call tree.
  // updates.root_function_call_id is the ID of this function call.
  optional ExecutionPlanUpdates updates = 4;
  // ID of the function call that initiated this function call.
  optional string source_function_call_id = 6;
}

message FunctionCallResponse {}

// ════════════════════════════════════════════
// HEARTBEAT (liveness + state sync + batched reports)
// ════════════════════════════════════════════

// Heartbeat serves triple purpose: liveness, state sync, AND batched reporting.
//
// Flow:
//   1. First contact: executor sends heartbeat with no state
//   2. Server responds with send_state=true (unknown executor)
//   3. Executor sends next heartbeat with full_state (identity + all containers)
//   4. Steady state: heartbeats carry batched reports (command responses,
//      allocation outcomes, log entries)
//   5. Every 5 min: executor includes full_state (drift healing)
//
// Batched reports (command_responses, allocation_outcomes, allocation_log_entries)
// are collected from dataplane buffers and included in every heartbeat.
// Items are only removed from buffers after the heartbeat RPC succeeds.
message HeartbeatRequest {
  optional string executor_id = 1;
  optional ExecutorStatus status = 3;

  // Full state: sent on first registration (after server asks) and
  // every 5 min for drift healing. Not sent on most heartbeats.
  optional DataplaneStateFullSync full_state = 5;

  // Batched reports (executor → server, guaranteed via collect/drain)
  repeated CommandResponse command_responses = 6;
  repeated AllocationOutcome allocation_outcomes = 7;
  repeated AllocationLogEntry allocation_log_entries = 8;
}

message HeartbeatResponse {
  // Server needs state (hash mismatch or unknown executor).
  optional bool send_state = 1;
}

// ════════════════════════════════════════════
// STATE: carried inside HeartbeatRequest
// ════════════════════════════════════════════

// Full state: executor identity + all container states.
// Sent on first registration (after server asks), server restart,
// and every 5 min for drift healing.
message DataplaneStateFullSync {
  optional string hostname = 1;
  optional string version = 2;
  optional HostResources total_resources = 3;
  optional HostResources total_container_resources = 4;
  repeated AllowedFunction allowed_functions = 5;
  map<string, string> labels = 6;
  optional string catalog_entry_name = 7;
  optional string proxy_address = 8;
  repeated ContainerState container_states = 9;
  reserved 10; // was function_call_watches — watchers eliminated by allocation_stream
}

// ════════════════════════════════════════════
// SHARED: Container state change notification
// ════════════════════════════════════════════

// Container state update sent by both server (in streams) and dataplane (in results).
// Allows atomic processing of container state + allocation results.
message ContainerStateUpdate {
  optional string container_id = 1;
  optional ContainerStatus status = 2;
  // Only set when status is TERMINATED.
  optional ContainerTerminationReason termination_reason = 3;
}

// ════════════════════════════════════════════
// COMMANDS: Server → Dataplane (delivered via poll_commands)
// ════════════════════════════════════════════

// Server → Dataplane: discrete action to execute.
message Command {
  uint64 seq = 1;
  oneof command {
    AddContainer add_container = 2;
    RemoveContainer remove_container = 3;
    RunAllocation run_allocation = 4;
    KillAllocation kill_allocation = 5;
    UpdateContainerDescription update_container_description = 7;
    SnapshotContainer snapshot_container = 8;
  }
  reserved 6; // was DeliverResult — results now delivered via AllocationEvent log
}

// Server → Dataplane: snapshot a container's filesystem.
// The container should be stopped before the snapshot is taken.
message SnapshotContainer {
  string container_id = 1;
  string snapshot_id = 2;
  // URI where the snapshot should be uploaded (e.g. "s3://bucket/snap.tar.zst").
  string upload_uri = 3;
}

message UpdateContainerDescription {
  string container_id = 1;
  // Updated sandbox metadata. When set, replaces the container's
  // sandbox_metadata. Used when a warm pool container is claimed by a sandbox
  // (sandbox_id and timeout_secs are set).
  optional SandboxMetadata sandbox_metadata = 2;
}

message AddContainer {
  ContainerDescription container = 1;
}

message RemoveContainer {
  string container_id = 1;
  optional ContainerTerminationReason reason = 2;
}

message RunAllocation {
  Allocation allocation = 1;
}

message KillAllocation {
  string allocation_id = 1;
}

// DeliverResult was removed. Function call results are now delivered
// deterministically via the AllocationEvent log.

enum ContainerTerminationReason {
  CONTAINER_TERMINATION_REASON_UNKNOWN = 0;
  CONTAINER_TERMINATION_REASON_STARTUP_FAILED_INTERNAL_ERROR = 1;
  CONTAINER_TERMINATION_REASON_STARTUP_FAILED_FUNCTION_ERROR = 2;
  CONTAINER_TERMINATION_REASON_STARTUP_FAILED_FUNCTION_TIMEOUT = 3;
  CONTAINER_TERMINATION_REASON_UNHEALTHY = 4;
  CONTAINER_TERMINATION_REASON_INTERNAL_ERROR = 5;
  CONTAINER_TERMINATION_REASON_FUNCTION_TIMEOUT = 6;
  CONTAINER_TERMINATION_REASON_FUNCTION_CANCELLED = 7;
  CONTAINER_TERMINATION_REASON_OOM = 8;
  CONTAINER_TERMINATION_REASON_PROCESS_CRASH = 9;
  CONTAINER_TERMINATION_REASON_STARTUP_FAILED_BAD_IMAGE = 10;
}

// ════════════════════════════════════════════
// Executor → Server: command responses
// ════════════════════════════════════════════

// Typed response to a command received via poll_commands.
// command_seq is 0 for unsolicited events (e.g. container crashes)
// that are not responses to any specific command.
//
// V2 protocol contract:
// - The dataplane sends individual AllocationFailed/AllocationCompleted messages
//   for each allocation with the correct failure reason via heartbeat.
// - ContainerTerminated is a container-lifecycle-only event. The server uses it
//   to update container state but does NOT derive allocation outcomes from it.
// - AllocationScheduled is a fast ack confirming the dataplane accepted the allocation.
message CommandResponse {
  optional uint64 command_seq = 1;
  oneof response {
    ContainerStarted container_started = 2;
    ContainerTerminated container_terminated = 3;
    AllocationScheduled allocation_scheduled = 6;
    SnapshotCompleted snapshot_completed = 7;
    SnapshotFailed snapshot_failed = 8;
  }
  reserved 4, 5;
}

// Dataplane → Server: snapshot completed successfully.
message SnapshotCompleted {
  string container_id = 1;
  string snapshot_id = 2;
  // URI where the snapshot was stored.
  string snapshot_uri = 3;
  // Size of the snapshot in bytes.
  uint64 size_bytes = 4;
}

// Dataplane → Server: snapshot failed.
message SnapshotFailed {
  string container_id = 1;
  string snapshot_id = 2;
  string error_message = 3;
}

message AllocationScheduled {
  string allocation_id = 1;
}

message ContainerStarted {
  string container_id = 1;
}

// Container-lifecycle event only. The server updates container state but does
// NOT derive allocation outcomes from this message. The dataplane is responsible
// for sending separate AllocationFailed messages for each affected allocation.
message ContainerTerminated {
  string container_id = 1;
  ContainerTerminationReason reason = 2;
}

// Reports successful completion of an allocation. The dataplane sends this for
// each allocation that finishes successfully, with the function's return value.
message AllocationCompleted {
  string allocation_id = 1;
  optional FunctionRef function = 2;
  optional string function_call_id = 3;
  optional string request_id = 4;
  oneof return_value {
    DataPayload value = 5;
    ExecutionPlanUpdates updates = 6;
  }
  optional uint64 execution_duration_ms = 7;
}

// Reports failure of an allocation. The dataplane sends this for each
// allocation that fails, with the specific failure reason for that allocation
// (e.g. OOM, timeout, function error, or container termination).
message AllocationFailed {
  string allocation_id = 1;
  AllocationFailureReason reason = 2;
  optional FunctionRef function = 3;
  optional string function_call_id = 4;
  optional string request_id = 5;
  optional DataPayload request_error = 6;
  optional uint64 execution_duration_ms = 7;
  // Container that ran this allocation. When set, the scheduler skips this
  // container when rescheduling retries, preventing assignment to a container
  // that may still appear alive (ContainerTerminated arrives separately).
  optional string container_id = 8;
}

// A single allocation outcome: either completed or failed.
// Sent via heartbeat's allocation_outcomes field for guaranteed delivery.
message AllocationOutcome {
  oneof outcome {
    AllocationCompleted completed = 1;
    AllocationFailed failed = 2;
  }
}

// ════════════════════════════════════════════
// ALLOCATION LOG (deterministic event log)
// ════════════════════════════════════════════

// A single entry in an allocation's deterministic event log.
// The server persists entries from both directions for replay.
message AllocationLogEntry {
  string allocation_id = 1; // Which allocation this entry belongs to
  uint64 clock = 2; // Server-assigned monotonic clock
  oneof entry {
    FunctionCallRequest call_function = 3; // Executor → Server: SDK called another function
    FunctionCallResult function_call_result = 4; // Server → Executor: result of a function call
  }
}

// Fetch historical log entries for replay (called before joining the live stream).
message GetAllocationLogRequest {
  string allocation_id = 1;
  uint64 after_clock = 2; // Resume point (0 = full log)
  optional uint32 max_entries = 3; // Pagination limit
}

message GetAllocationLogResponse {
  repeated AllocationLogEntry entries = 1;
  optional uint64 last_clock = 2; // Clock of last returned entry
  optional bool has_more = 3; // True if more entries exist
}

// ════════════════════════════════════════════
// LONG-POLL RPCs (replace streaming RPCs)
// ════════════════════════════════════════════

// Long-poll for pending commands (server holds request open until
// commands available or timeout, ~5 min).
//
// Each poll carries the ack for data processed from the previous poll.
// The server drains acked items first, then returns new data.
message PollCommandsRequest {
  string executor_id = 1;
  // Drain commands with seq <= this value. Set to the highest seq
  // successfully processed from the previous poll response.
  optional uint64 acked_command_seq = 2;
}

message PollCommandsResponse {
  repeated Command commands = 1;
}

// Long-poll for pending function call results (server holds request
// open until results available or timeout, ~5 min).
//
// Same ack pattern as poll_commands.
message PollAllocationResultsRequest {
  string executor_id = 1;
  // Drain results with seq <= this value.
  optional uint64 acked_result_seq = 2;
}

message PollAllocationResultsResponse {
  repeated SequencedAllocationResult results = 1;
}

// Wrapper that adds a per-executor monotonic seq to each buffered result.
// The seq is assigned by the server when push_result() buffers the entry.
message SequencedAllocationResult {
  uint64 seq = 1;
  AllocationLogEntry entry = 2;
}

// ════════════════════════════════════════════
// REMOVED MESSAGES (kept as reserved comments)
// ════════════════════════════════════════════

// GetCommandStreamRequest removed — replaced by PollCommandsRequest.
// ReportCommandResponsesRequest/Response removed — folded into HeartbeatRequest.
// ReportAllocationActivitiesRequest/Response removed — folded into HeartbeatRequest.
// AllocationStreamRequest removed — log entries folded into HeartbeatRequest,
//   results delivered via PollAllocationResultsResponse.
// AllocationStreamResponse removed — replaced by PollAllocationResultsResponse.

// Internal API for scheduling and running allocations on Executors. Executors are acting as clients of this API.
// Server is responsible for scheduling allocations on Executors and Executors are responsible for running the allocations.
//
// Rename with caution. Existing clients won't find the service if the service name changes. A HTTP2 ingress proxy
// might use the service name in it HTTP2 path based routing rules. See how gRPC uses service names in its HTTP2 paths
// at https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md.
service ExecutorAPI {
  // Heartbeat: liveness + optional state sync + batched reports
  // (command responses, allocation outcomes, log entries).
  rpc heartbeat(HeartbeatRequest) returns (HeartbeatResponse) {}

  // Long-poll for pending commands. Server holds request open until
  // commands are available or ~5 min timeout.
  rpc poll_commands(PollCommandsRequest) returns (PollCommandsResponse) {}

  // Long-poll for pending function call results. Server holds request
  // open until results are available or ~5 min timeout.
  rpc poll_allocation_results(PollAllocationResultsRequest) returns (PollAllocationResultsResponse) {}
}
